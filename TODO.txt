Protocol:
*- for each server generate a list of messages it can receive
*- assemble by hand a list of messages which es_interface_server can send to other servers
#- {set, flux_now, Flux} and {set_now, flux, Flux} transform to {set, flux, Flux}
#0 es_makeup_buffer_server {action, _, [RCS, VADD]} transform to {action, _, VADD} - beware of deadlock with es_core_server

General features:
*- throw error if something is missing from priv dir
*- es_config_server:send_tick/2 should use gen_server:cast instead of gen_server:call
*0 extract client code from egon_server
*0 logger server: tracking parameters and storing them
$- es_action_server should log it's actions
#+ logging everthing
#0 changing simulation speed

egon_client:
$- xls generation

Separating implementation and configuration:
$+ move hardcoded setpoints from es_rod_controller_server:rod_speed to curvebook/pls

Erlang/OTP problem:
#? errors in snapshot file do not generate error report
#? if two gen_tcp servers listen on the same port, they fail silently
#? if supervisor fails to start it's children, no error is generated

Userfriendlyness:
$+ writing unit tests
$+ writing documentation
#0 generating client-server protocol from documentation (list all handle_call methods which have some modifier in it's documentation)
#0 building a release (OTP in Action, chapter 10)

Multi-user:
*- spawn new process for each interface_server request
*0 Start simulator children on demand and transfer the socket to it
*+ Ability to connect to existing simulator child

Bugs:
*- [34,228,228,228,228,34] = es_interface_client:send(S1, "{get, es_rod_position_server, control_position}\n") - remove quotes (34)
* remove all mention of ports

LEGEND:

Importance:
* - high
% - medium
# - low

Complexity:
+ - high
0 - medium
- - low
